package main

import (
	"fmt"
	"time"
	"math/rand"
)

func main() {
    a := []int{9,3,45,2,6,3,43,1,6,24,53,14,23,54,34,62,43,55,23,53,12,95}
    fmt.Printf("%v\n",quicksort(a))
}

func quicksort(a []int) []int {
    if len(a) < 2 {
        return a
    }
     
    seed := int64(time.Now().UnixNano())
    rand.Seed(seed)
    left, right := 0, len(a)-1
     
    pivot := rand.Int() % len(a)

    //выносим наше значиние для сравнения в конец массива,
    //чтобы отсортировать его полностью
    a[pivot], a[right] = a[right], a[pivot] 

    //слева от left будут числа меньше pivot'a, справа больше
    for i := range a { //проходимся по всему массиву
        if a[i] < a[right] { 
            // если i-ое значение меньше pivot'а
            // значит оно должно быть слева от left
            // для этого нужно его поменять с текущим left и увеличить left на единицу
            a[left], a[i] = a[i], a[left] // если left == i, ничего не поменяется,
            // просто увеличим количество отсортированных элементов
            left++
        } //если условие не выполняется значит попалось значение которое больше pivot
          //и оно должно быть справа от left.
          //left будет указывать на это значение до тех пор пока мы не найдем следующее значение меньшее pivot
          //как только найдем поменяем его с этим большим значением и увеличим left
          //таким образом у нас слева от left опять будут значения только меньшие pivot
          //если же значения меньших нашего больше нет, left так и останется указывать
          //первый элемент подмассива чисел больших чем pivot, и все они будут справа
    }

    a[left], a[right] = a[right], a[left] // устанавливаем pivot в середину массива
    //между 2мя отсортированными подмассивами
     
    //отсортировываем 2 подмассива
    quicksort(a[:left])
    quicksort(a[left+1:])
     
    return a
}
